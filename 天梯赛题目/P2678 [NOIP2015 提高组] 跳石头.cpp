/*题目描述
一年一度的“跳石头”比赛又要开始了！这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。
组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有 N 块岩石（不含起点和终点的岩石）。
在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。为了提高比赛难度，
组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，
组委会至多从起点和终点之间移走 M 块岩石（不能移走起点和终点的岩石）。

输入格式
第一行包含三个整数 𝐿,𝑁,𝑀
L,N,M，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。
保证 𝐿≥1 且 𝑁≥𝑀≥0

接下来 N 行，每行一个整数，第 i 行的整数 𝐷𝑖 (0<𝐷𝑖<𝐿)， 表示第 i 块岩石与起点的距离。
这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置。

输出格式
一个整数，即最短跳跃距离的最大值。

输入输出样例
输入 
25 5 2 
2
11
14
17 
21
输出 
4

说明/提示
输入输出样例 1 说明
将与起点距离为 2 和 14 的两个岩石移走后，最短的跳跃距离为 4
（从与起点距离 17 的岩石跳到距离 21 的岩石，或者从距离 21 的岩石跳到终点）。


数据规模与约定
对于20%20%的数据，0≤M≤N≤10。
对于50%50% 的数据，0≤≤M≤N≤100。
对于100%100% 的数据，0≤𝑀≤𝑁≤50000,1≤𝐿≤10^9。
*/




//思路：用二分法找，看看小于哪个距离能被删除m个以下，就成立，有点逆向思维的样子，用每个距离去试题目的条件
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<algorithm>
using namespace std;
int len, n, m;
int arr[100000];
int check(int x)
{
	int prev = 0;
	int cnt = 0;
	for (int i = 1; i <= n + 1; ++i)
	{
		if (x > (arr[i] - prev))//不可直接arr[i]-arr[i-1]，因为不知道前面数据有没有删除
		{
			cnt++;
		}
		else
		{
			prev = arr[i];//给前一个赋值
		}
	}
	return cnt > m;//根据题目，是至多移走m个所以小于等于m是正确条件
}
int main()
{
	cin >> len >> n >> m;
	arr[0] = 0;
	arr[n + 1] = len;
	for (int i = 1; i <= n; ++i) cin >> arr[i];
	int l, r, mid, ans;
	l = 0, r = len;
	//二分法判断mid是否符合条件
	while (l <= r)
	{
		mid = (l + r) / 2;
		if (check(mid))
		{
			r = mid - 1;
		}
		else
		{
			ans = mid;
			l = mid + 1;
		}
	}
	cout << ans;
}