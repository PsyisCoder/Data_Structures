/*
题目地址：https://www.luogu.com.cn/problem/P2123
题目描述   
皇后有 𝑛n 位大臣，每位大臣的左右手上面分别写上了一个正整数。恰逢国庆节来临，
皇后决定为 𝑛n 位大臣颁发奖金，其中第 𝑖i 位大臣所获得的奖金数目为第 𝑖−1i−1 
位大臣所获得奖金数目与前 𝑖i 位大臣左手上的数的和的较大值再加上第 𝑖i 位大臣
右手上的数。
形式化地讲：我们设第 𝑖i 位大臣左手上的正整数为 𝑎𝑖ai​，右手上的正整数为 𝑏𝑖bi​，
则第 𝑖i 位大臣获得的奖金数目为 𝑐𝑖ci​ 可以表达为：

当然，吝啬的皇后并不希望太多的奖金被发给大臣，所以她想请你来重新安排一下队伍
的顺序，使得获得奖金最多的大臣，所获奖金数目尽可能的少。
注意：重新安排队伍并不意味着一定要打乱顺序，我们允许不改变任何一位大臣的位置。
输入格式
第一行包含一个正整数 𝑇T，表示测试数据的组数。
接下来 𝑇T 个部分，每个部分的第一行包含一个正整数 𝑛n，表示大臣的数目。
每个部分接下来 𝑛n 行中，每行两个正整数，分别为 𝑎𝑖ai​ 和 𝑏𝑖bi​，含义如上文所述。
输出格式
共 𝑇T 行，每行包含一个整数，表示获得奖金最多的大臣所获得的奖金数目。
输入输出样例
输入 #1复制1
3
4 1
2 2
1 2
输出 #1复制8
输入 #2复制2
5
85 100
95 99
76 87
60 97
79 85
12
9 68
18 45
52 61
39 83
63 67
45 99
52 54
82 100
23 54
99 94
63 100
52 68
输出 #2复制528
902*/

















/*写正确解法之前，我先要好好感谢一下那位第一个写正解的大佬，是他的博客和
他的数据才引发了我以下的思考。 既然要使排序能满足传递性，就应该想出一个对
所有数普遍适用的一个排序条件，而不只针对于相邻的两个数。上面得到的⑤式肯定
要被用起来。再仔细观察一下这个式子：
𝑚𝑖𝑛(𝑎𝑖,𝑏𝑗)≤𝑚𝑖𝑛(𝑎𝑗,𝑏𝑖)
可以发现，大概应该和a与b的大小关系有关（𝑎𝑖ai​和𝑏𝑖bi​哪个大）。还有，要使一个
数排在前面，那么a越小越好，b越大越好。我们先按a与b的大小关系把所有数据分为
三大组，然后开始讨论：
1.当𝑎𝑖<𝑏𝑖​，aj​<bj​时，ai​≤aj​，应该按a升序排序（𝑎𝑖ai​和𝑎𝑗aj​相等时无所谓）。
2.当𝑎𝑖=𝑏𝑖​，aj​=bj​时，爱怎么排怎么排。
3.当𝑎𝑖>𝑏𝑖​，𝑎𝑗>𝑏𝑗​时，bi​≥bj​，应该按b降序排序。
那么这三大组之间应该怎样排序呢？
1组和2组，1组在2组前肯定能保证满足条件。2组和3组，2组在3组前面肯定能保证满
足条件。那么1组在前，2组在中，3组在后，是肯定能保证满足要求的。
我们令𝑑𝑖=𝑎𝑖−𝑏𝑖∣𝑎𝑖−𝑏𝑖∣di​=∣a​−b​∣a​−b​​，那么1组的d值为-1，2组为0，3组为1。
于是我们得到了最终的排序条件：先按d值排序；然后若d值小于等于0，按a升序排序
（这里把2组归入1组）；若d值大于0，则按b降序排序。 这样就可以满足传递性了。*/
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
struct node
{
    int x, y, d;
    bool operator <(node a) const
    {
        if (d != a.d) return d < a.d;
        if (d <= 0) return x < a.x;
        return y > a.y;
    }
}a[20005];
int t, n;
long long c[20005];
int main()
{
    cin >> t;
    for (int k = 1; k <= t; k++)
    {
        cin >> n;
        for (int i = 1; i <= n; i++)
        {
            cin >> a[i].x >> a[i].y;
            if (a[i].x > a[i].y) a[i].d = 1;
            else if (a[i].x < a[i].y) a[i].d = -1;
            else a[i].d = 0;
        }
        sort(a + 1, a + n + 1);
        long long s = 0;
        for (int i = 1; i <= n; i++)
        {
            s += a[i].x;
            c[i] = max(c[i - 1], s) + a[i].y;
        }
        cout << c[n] << '\n';
    }
}