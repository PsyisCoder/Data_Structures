/*给定两个整数集合，它们的相似度定义为：N 
c
​
 /N 
t
​
 ×100%。其中N 
c
​
 是两个集合都有的不相等整数的个数，N 
t
​
 是两个集合一共有的不相等整数的个数。你的任务就是计算任意一对给定集合的相似度。

输入格式：
输入第一行给出一个正整数N（≤50），是集合的个数。随后N行，每行对应一个集合。每个集合首先给出一个正整数M（≤10 
4
 ），是集合中元素的个数；然后跟M个[0,10 
9
 ]区间内的整数。

之后一行给出一个正整数K（≤2000），随后K行，每行对应一对需要计算相似度的集合的编号（集合从1到N编号）。数字间以空格分隔。

输出格式：
对每一对需要计算的集合，在一行中输出它们的相似度，为保留小数点后2位的百分比数字。

输入样例：
3
3 99 87 101
4 87 101 5 87
7 99 101 18 5 135 18 99
2
1 2
1 3
输出样例：
50.00%
33.33%
*/






//题解：使用set容器，可以去重，并且可以查找相同值
//题意：相同元素的个数/元素总素（不能重复）   

#include<bits/stdc++.h>
using namespace std;
set<int> s[55];//定义一个set容器数组
int main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; ++i)
    {
        int m;
        cin >> m;
        while (m--)
        {
            int num;
            cin >> num;
            //输入到set里面
            s[i].insert(num);
        }
    }
    int k;
    cin >> k;
    while (k--)
    {
        int a, b;
        cin >> a >> b;
        int cnt = 0, cnta = s[a].size(), cntb = s[b].size();//set容器会去重所以可以直接这样定义
        //定义一个迭代器
        set<int>::iterator it;
        for (it = s[a].begin(); it != s[a].end(); ++it)
        {
            //如果a集合里的元素b集合也存在，那么cnt++
            if (s[b].find(*it) != s[b].end())
            {
                cnt++;
            }
        }
        printf("%.2lf%%\n", cnt * 1.0 / (cnta + cntb - cnt) * 100);
    }
}