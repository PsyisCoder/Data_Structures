/*一个正整数 N 的因子中可能存在若干连续的数字。例如 630 可以分解为 3×5×6×7，
其中 5、6、7 就是 3 个连续的数字。给定任一正整数 N，要求编写程序求出最长连续
因子的个数，并输出最小的连续因子序列。

输入格式：
输入在一行中给出一个正整数 N（1<N<2^31）

输出格式：
首先在第 1 行输出最长连续因子的个数；然后在第 2 行中按 因子1*因子2*……*因子k
的格式输出最小的连续因子序列，其中因子按递增顺序输出，1 不算在内。

输入样例：
630

输出样例：
3
5*6*7
*/





/*题解：题目要求的结果首先得是连续因子，其次因子乘积也得是因子，输出最长的连续因子，
如果长度一样就输出最小的连续因子序列。之前我没有注意到连续因子乘积也必须是因子，所
以测试点3一直通过不了。以1260举例，它的因子有2 3 4 5 6 7 9 10 12 14 15 18 20 21
28 30 35 36…我最开始觉得是连续因子个数是6因为2×3×4×5×6×7。但后来我意识到2×3×4×5×
6×7 = 5040 > 1260，所以我又修改代码觉得结果是5因为2×3×4×5×6 = 720 < 1260。但我又
错了，因为1260 % 720 != 0即720并不是1260的因子。正确答案应该是3×4×5，因为3、4、5
首先是1260的因子，其次3、4、5连续，其次乘积也是因子即1260 % (3×4×5) == 0，所以答案
是3和3×4×5。如果输入6，答案应该是2和2×3。但这个题测试可能不全，有的代码不管输入6的2
和2×3还是1和2，提交都AC。比如你把我下面的代码中的m + 1改成m然后输入6虽然结果是1和2，
和m + 1的结果2和2×3不一样，但提交都AC，至少我写这篇博客是系统是这样的，说不定以后老师
发现了这个bug会修改的。 输入6，答案应该是2和2×3，也就是判断是否因子时，m必须加1，因为
int m = sqrt(n)，m是整型，整型是向下取整。虽然连续因子肯定不会以sqrt(n) + 1打头，因
为如果是素数，那只有一个因子即本身。如果不是素数，那么肯定有一个因子在小于等于sqrt(n)
，如果最长序列为1的话也是在2~sqrt(n)之中，不可能是sqrt(n) + 1；如果最长序列大于1的话，
更不可能是以sqrt(n) + 1打头的，因为sqrt(n) + 1乘以下一个因子必大于n。但sqrt(n) + 1
是有可能包括在前一个因子的序列中，就好比输入6的这种情况。所以sqrt(n) + 1还是要考虑在内
的，它后面的因子就不用考虑了，肯定是不可能的，因为不会有以它们开始的序列的。

分析结束，总之题目一定要好好理解，代码AC后还要想想自己的思想是否全面，以防判题系统考虑
不周。以下是我的AC代码。*/
#include<iostream>
#include<cmath>
using namespace std;
int main()
{
    int n, m, i, j, pos, sum, len, mlen = 0, t = 0;
    cin >> n;
    m = sqrt(n);
    int s[m];
    for (i = 2; i <= m + 1; i++) //连续因子相乘后还是因子，因此符合题意的因子肯定只在2~sqrt(n)+1之间
    {
        if (n % i == 0)
            s[t++] = i;
    }
    if (t == 0)//说明是素数
        cout << '1' << endl << n << endl;
    else if (t == 1)//如果只有一个因数，那么最长连续因子的个数为1，最小的连续因子序列就为s[0]
        cout << '1' << endl << s[0] << endl;
    else//大于两个因数则进入循环
    {
        for (i = 0; i < t - 1; i++)
        {
            sum = s[i];
            len = 1;
            for (j = i; j < t - 1; j++)
            {
                if (s[j + 1] - s[j] == 1 && n % (sum * s[j + 1]) == 0)//判断是否连续  连续的话判断相乘后是否还是因子
                {//因为题目要求的是连续因子，既要连续，连续相乘后还得是因子
                    sum = sum * s[j + 1];
                    len++;
                }
                else//不符合直接跳出，判断以下一个因子开始的序列是否符合
                    break;
            }
            if (len > mlen)//如果长度大于最大长度则记录开始的因子序列
            {//如果等于则不变，因为题目要求输出的是在序列最长的情况下输出最小连续因子
                mlen = len;//更新最长序列
                pos = i;
            }
        }
        cout << mlen << endl;//按要求输出
        cout << s[pos];
        for (i = pos + 1; i < pos + mlen; i++)
            cout << '*' << s[i];
        cout << endl;
    }
    return 0;
}

