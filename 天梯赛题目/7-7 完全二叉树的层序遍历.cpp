/*题目：一个二叉树，如果每一个层的结点数都达到最大值，
则这个二叉树就是完美二叉树。对于深度为 D 的，有 N 个
结点的二叉树，若其结点对应于相同深度完美二叉树的层序
遍历的前 N 个结点，这样的树就是完全二叉树。

给定一棵完全二叉树的后序遍历，请你给出这棵树的层序遍历结果。

输入格式：
输入在第一行中给出正整数 N（≤30），即树中结点个数。
第二行给出后序遍历序列，为 N 个不超过 100 的正整数。
同一行中所有数字都以空格分隔。

输出格式：
在一行中输出该树的层序遍历序列。所有数字都以 1 
个空格分隔，行首尾不得有多余空格。

输入样例：
8
91 71 2 34 10 15 55 18
输出样例：
18 34 55 71 2 10 15 91
*/




/*题解：*/
#include<iostream>
using namespace std;
int a[101], b[101], flag = 1;
void dfs(int x, int n)
{
    if (x <= n)
    {
        //如果完全二叉树按照从上到下，从左到右的从1开始顺序编号
        //则完全二叉树的左节点为当前节点编号x2，右节点为当前节点编号x2+1。
        dfs(x * 2, n);
        dfs(x * 2 + 1, n);
        //后序遍历先找到的也就是a中的第一个因为a就是后序遍历，所以从1开始循环
        b[x] = a[flag++];
    }
}
int main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; ++i)
    {
        cin >> a[i];
    }
    dfs(1, n);
    for (int i = 1; i <= n; ++i)
    {
        if (i != n)
            cout << b[i] << " ";
        else
            cout << b[i] << endl;
    }
    return 0;
}